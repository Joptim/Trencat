.. _speed-profile-optimization:

Speed profile optimization
--------------------------

A key aspect in train automation is to define algorithms to generate optimal reference trajectories. The aim of such trajectories is to determine what should be the position, velocity, traction and braking force of the train at each time period. The *speed profile optimization* problem consists in solving an optimal control problem based on the train operation model described in :ref:`train-dynamic-models`\ . The objective function is usually a trade-off between train efficiency and riding comfort. In addition, the problem must be feasible, meaning that the train must depart and arrive on time (if possible) and stick to the speed limits at each segment.

.. figure:: /_static/speed_profile_ATO.jpg
   :alt: Speed profile generated by the :term:`ATO`.
   
   Example of a speed profile generated by the :term:`ATO` (obtained from [YTYXHG]_\ ).

Once a profile has been generated, the train must stick to this profile between the two stations. If the train cannot attain the profile due to disturbances, then a new profile must be re-computed on the fly based on the current position and velocity of the train.

The speed profile generation problem has been solved from many points of view. Check [YTYXHG]_ for exhaustive references of state-of-the-art solutions for this problem.

.. speed-profile-optimization-definitions:

Definitions
^^^^^^^^^^^

Consider that we start from a train station *A* and that we must drive the train to another station *B*, which is *10km* away, in exactly :math:`T` seconds. During our journey, the train can be found in four different stages: **acceleration**, **cruising**, **coasting** and **braking**. To understand better these states, recall the Newton's train dynamics equation :eq:`traindynamicseq` introduced in :ref:`train-dynamic-models`, and let us solve it for the acceleration of the train:

.. math::
   
   \frac{dv(t)}{dt} = \frac{u(t) - [R_b(t) + R_l(s(t), v(t))]}{m\rho}

From the equation we deduce:

   - During **acceleration** the train must increase its velocity (derivative is positive). To do so, the traction force :math:`u(t)` must be greater than the sum of resistances (basic and track resistances, i.e. slope, curve and tunnel resistances).
   - During **cruising** the train must maintain its velocity. At this point :math:`\frac{dv(t)}{dt} = 0` and the train will have to apply a force equal to the sum of resistances. Therefore, the train will apply a positive traction force :math:`u(t)` if the sum of resistances is positive or apply a braking force if the sum is negative (for example, if the downwards slope is high).
   - During **coasting** the power to the engine is removed (:math:`u(t) = 0`). The train will either reduce its velocity if the sum of resistances is positive or increase velocity if the sum of resistances is negative.
   - During **braking** state the train must decrease its velocity (derivative is negative). To do so, the braking force :math:`u(t)` must be less than the sum of the resistances until the train stops.

The sign of the traction/bracking force is important. If :math:`u(t) > 0`, then the train is consuming energy from the grid system. In addition, some trains are able to obtain energy from the braking force (i.e., when :math:`u(t) < 0`) by the friction generated between the brakes and the steel wheels, thus, the energy consumption may be compensated with energy from braking. 

.. speed-profile-optimization-introduction:

Introducing the optimal speed profile problem
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To begin with, the next figure shows some examples of a speed profiles.

.. figure:: /_static/speed_profile_introduction_1.jpg
   :alt: Train speed profiles examples.
   
   Speed profiles examples.

First of all, notice that we introduced a distance-velocity graph instead of a time-velocity graph. Usually a time-velocity graph is easier to understand, and in fact, we are going to use *time* as the independent variable. However, a distance-velocity graph is more appropiate to compare different profiles in the same graph since curves start and end at the same domain points. We will see the advantatge as we read.

Notice that the train represented by the red dotted line drives almost as fast as it can. As a consequence, it will be reach *Station B* sooner, but it will consume a lot more energy. On the contrary, the train in dashed blue will require quite a lot of time to get to destination, but it will require less energy consumption. Between the two cases, the green continuous line shows us that states can also change continuously, rather than piecewise linear, with a balanced energy consumption.

Our goal is to find a trade-off between arriving on time to destination and being as energy efficient as possible. In other words, among all the possible ways to drive a train within the schedule, we want to know which is the most efficient driving pattern.

While there are mathematical algorithms to obtain non linear profiles, we will consider only piecewise linear profiles. With this assumption we are reducing a lot the complexity of the problem, making it easier and quicker to solve, while still obtaining high quality solutions. Even more, instead of considering an infinite number of stages, we will restrict to a finite set of stages. This is, we are going to discretize the distance and velocity that can be obtained.

.. figure:: /_static/speed_profile_introduction_2.jpg
   :alt: Speed profile optimization with distance-state discretized.
   
   Speed profile optimization with distance-state discretized.

The previous figure shows an example of distance-velocity discretization. The blue dots represent the possible (finite) states that the train can achieve. Notice that neither distance nor velocity discretization need to be equally distributed. Now the number of states is finite and so the arriving time at station B. For this reason it is no longer true that the train can arrive at a specific moment in time, but it is still true that the train can arrive within a time frame, provided that this time frame is large enough.

It is important to remark that if we consider lots of states, the quality of the profile will be high, but the algorithm will take a long time to find it. On the other hand, if we consider too few states, the quality of the solution will be quite poor, but the algorithm will find it really quick. Again, choosing the right number of states is the key to have good enough profiles quick enough.

We are almost there. The blue dots in the previous figure have been deliverately depicted to lead us to graph theory. Consider a graph where nodes are all the possible (finite) states that the train can achieve (blue dots). The links of the graph connect nodes that are reachable form one state (vertical black dashed lines) to the next state. The next figure depicts the possible links of a single node.

.. figure:: /_static/speed_profile_introduction_3.jpg
   :alt: Outgoing links from one distance state (vertical black dashed line) to the next one.
   
   Outgoing links from one distance state (vertical black dashed line) to the next one.

This figure shows that certain states cannot be reached due to phisical constraints, such as maximum acceleration/braking force reached. The graph only contains links to feasible states.

Now that the problem is modelled as a graph, to find the most efficient driving profile is equivalent to solve a *minimum flow problem* on a graph/network, where the cost of each link is the work done by the train to move from one state to the next one, while sticking to timetable requirements. The rest of the section is devoted to compute such work.

Computing physical magnitudes
"""""""""""""""""""""""""""""

Consider the situation in the next figure. The train is in position :math:`s_i` with velocity :math:`v_i` at time :math:`t_i` and it has to accelerate to achieve velocity :math:`v_j` at position :math:`s_j`. We want to know how much time the train needs to carry out this transition, how much `work <https://en.wikipedia.org/wiki/Work_(physics)>`_ it will do and what's the train average `power <https://en.wikipedia.org/wiki/Power_(physics)>`_ over this segment.

.. figure:: /_static/speed_profile_introduction_4.jpg
   :alt: Moving from one state to the next one.
   
   Moving from one state to the next one.

To simplify computations, let's assume that this transition is done with constant acceleration. The time needed for this transition is computed using kinemic formula :math:`\Delta s = \frac{1}{2}(v_j + v_i)\Delta t`:

.. math::

    \Delta t = \frac{2\Delta s}{v_j + v_i},\quad \text{i.e.} \quad t_j = t_i + \frac{2(s_j-s_i)}{v_j+v_i}.

.. note::

   The previous formula is not valid if both :math:`v_i` and :math:`v_j` equal zero. Since the train is stopped it implies that :math:`s_i =  s_j`, which contradicts the situation depticted (:math:`s_j > s_i`).

Time train acceleration is straightforward to compute:

.. math::

    a = \frac{\Delta v}{\Delta t} = \frac{v_j-v_i}{t_j-t_i}.

The computation of the work done by the train is a bit tricky. A way to compute the work done by the train in this segment is:

.. math::

   W_{ij} = \int_{t_i}^{t_j}u(t)v(t)dt

Recall again Newton's equation :eq:`traindynamicseq`. Due to the space discretization, the term :math:`mg\sin(s)` is constant in the entire segment. In addition, the term :math:`l_t(s)` is also constant in the entire segment. Acceleration :math:`a` is also constant along the track by assumption. Therefore, :eq:`traindynamicseq` can be refactored as

.. math::

   m\rho a = u(t) - C_1 - C_2 v^2(t),

where :math:`C_1` and :math:`C_2` are constants. The work done by the train in this segment is computed as the integral of traction force times velocity:

.. math::

   \begin{array}{rl}
   W_{ij} =& \int_{t_i}^{t_j}u(t)v(t)dt\\
     =& \int_{t_i}^{t_j} (m\rho a + C_1)v(t)dt + \int_{t_i}^{t_j}C_2v^3(t)dt\\
     \stackrel{v(t) = at}=& (m\rho a^2 + aC_1)\int_{t_i}^{t_j}tdt + a^3 C_2\int_{t_i}^{t_j}t^3dt\\
     =& (m\rho a^2 + aC_1)\frac{t_j^2 - t_i^2}{2} + a^3 C_2\frac{t_j^4 - t_i^4}{4}.
   \end{array}

Until here everything is correct, but let's go a little bit further. Notice that the previous formula includes the work done by the traction force and the braking force. It is more accurate, though, to minimise only the work done by the traction force since the train consumes energy from the grid only when :math:`u(t) > 0` but not when :math:`u(t) < 0`. Work is then computed as

.. math::

   \overline{W_{ij}} = \int_{t_i}^{t_j}\max(u(t), 0)v(t)dt = \int_{t_i}^{t_j}u(t)v(t)dt - \int_{t\in\{t_i \leq t \leq t_j | u(t) < 0\}}u(t)v(t)dt

The set :math:`\{t_i \leq t \leq t_j | u(t) < 0\}` is computed as follows:

.. math::

   \begin{array}{rl}
   u(t) < 0 \Leftrightarrow & m\rho a + C_1 + C_2v^2(t) < 0\\
   \stackrel{v(t)=a(t-t_i)}{\Leftrightarrow} & m\rho a + C_1 + C_2a^2(t-t_i)^2 < 0\\
   \Leftrightarrow & (t-t_i)^2 < \frac{-m\rho a - C_1}{a^2C_2}\\
   \Leftrightarrow & t_i - \sqrt{\frac{-m\rho a - C_1}{a^2C_2}} < t < t_i + \sqrt{\frac{-m\rho a - C_1}{a^2C_2}}\\
   \end{array}

The last inequality is valid only if :math:`m\rho a + C_1 < 0`. For convenience, let us denote :math:`\tilde{t_i} := t_i - \sqrt{\frac{-m\rho a - C_1}{a^2C_2}}` and :math:`\tilde{t_j} := t_i + \sqrt{\frac{-m\rho a - C_1}{a^2C_2}}`. Finally, the work done only by the traction force is computed as 

.. math::

   \overline{W_{ij}} = 
   \left\{\begin{array}{rl}
      \int_{t_i}^{t_j}u(t)v(t)dt,& \text{if } m\rho a + C_1 < 0,\\
      \int_{t_i}^{t_j}u(t)v(t)dt - \int_{\max(t_i, \tilde{t_i}) = t_i}^{min(t_j, \tilde{t_j})}u(t)v(t)dt,& \text{otherwise.}
   \end{array}\right.

Regarding the average power of the train, it is computed as:

.. math::

   P_{ij} = \frac{\Delta W_{ij}}{\Delta t},\quad \text{or} \quad \overline{P_{ij}} = \frac{\Delta \overline{W_{ij}}}{\Delta t}
